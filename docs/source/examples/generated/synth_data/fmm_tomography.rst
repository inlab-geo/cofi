
.. DO NOT EDIT.
.. THIS FILE WAS AUTOMATICALLY GENERATED BY SPHINX-GALLERY.
.. TO MAKE CHANGES, EDIT THE SOURCE PYTHON FILE:
.. "examples/generated/synth_data/fmm_tomography.py"
.. LINE NUMBERS ARE GIVEN BELOW.

.. only:: html

    .. note::
        :class: sphx-glr-download-link-note

        :ref:`Go to the end <sphx_glr_download_examples_generated_synth_data_fmm_tomography.py>`
        to download the full example code

.. rst-class:: sphx-glr-example-title

.. _sphx_glr_examples_generated_synth_data_fmm_tomography.py:


Seismic Wave Tomography via Fast Marching
=========================================

.. GENERATED FROM PYTHON SOURCE LINES 9-14

|Open In Colab|

.. |Open In Colab| image:: https://img.shields.io/badge/open%20in-Colab-b5e2fa?logo=googlecolab&style=flat-square&color=ffd670
   :target: https://colab.research.google.com/github/inlab-geo/cofi-examples/blob/main/examples/fmm_tomography/fmm_tomography.ipynb


.. GENERATED FROM PYTHON SOURCE LINES 17-36

.. raw:: html

   <!-- Again, please don't touch the markdown cell above. We'll generate badge 
        automatically from the above cell. -->

.. raw:: html

   <!-- This cell describes things related to environment setup, so please add more text 
        if something special (not listed below) is needed to run this notebook -->

..

   If you are running this notebook locally, make sure you’ve followed
   `steps
   here <https://github.com/inlab-geo/cofi-examples#run-the-examples-with-cofi-locally>`__
   to set up the environment. (This
   `environment.yml <https://github.com/inlab-geo/cofi-examples/blob/main/envs/environment.yml>`__
   file specifies a list of packages required to run the notebooks)


.. GENERATED FROM PYTHON SOURCE LINES 39-107

.. raw:: html

   <!-- TODO - background introduction for this problem. -->

In this notebook, we use ``cofi`` to run a seismic wave tomography
example, in which the forward calculation is based on the Fast Marching
Fortran code by Nick Rawlinson. The Fast Marching code is wrapped in
package ``espresso``.

Theoretical background
----------------------

The goal in travel-time tomography is to infer details about the
velocity structure of a medium, given measurements of the minimum time
taken for a wave to propagate from source to receiver. For seismic
travel times, as we change our model, the route of the fastest path from
source to receiver also changes. This makes the problem nonlinear, as
raypaths also depend on the sought after velocity or slowness model.

Provided the ‘true’ velocity structure is not *too* dissimilar from our
initial guess, travel-time tomography can be treated as a weakly
non-linear problem. In this notebook we optionally treat the ray paths
as fixed, and so it becomes a linear problem, or calculate rays in the
velociuty model.

The travel-time of an individual ray can be computed as

.. math:: t = \int_\mathrm{path} \frac{1}{v(\mathbf{x})}\,\mathrm{d}\mathbf{x}

This points to an additional complication: even for a fixed path, the
relationship between velocities and observations is not linear. However,
if we define the ‘slowness’ to be the inverse of velocity,
:math:`s(\mathbf{x}) = v^{-1}(\mathbf{x})`, we can write

.. math:: t = \int_\mathrm{path} {s(\mathbf{x})}\,\mathrm{d}\mathbf{x}

which *is* linear.

We will assume that the object we are interested in is 2-dimensional
slowness field. If we discretize this model, with :math:`N_x` cells in
the :math:`x`-direction and :math:`N_y` cells in the
:math:`y`-direction, we can express :math:`s(\mathbf{x})` as an
:math:`N_x \times N_y` vector :math:`\boldsymbol{s}`.

**For the linear case**, this is related to the data by

.. math:: d_i = A_{ij}s_j 

where :math:`d_i` is the travel time of the ith path, and where
:math:`A_{ij}` represents the path length in cell :math:`j` of the
discretized model.

**For the nonlinear case**, this is related to the data by

.. math:: \delta d_i = A_{ij}\delta s_j 

where :math:`\delta d_i` is the difference in travel time, of the ith
path, between the observed time and the travel time in the reference
model. Here :math:`A_{ij}` represents the path length in cell :math:`j`
of the discretized model. The parameters :math:`\delta s_j` are slowness
perturbations to the reference model.

In this notebook we form and solve a travel time tomography problem
using model damping and 2nd derivative smoothing. For forward modelling,
a fast marching wave front tracker is used, utilizing the Fast Marching
Fortran code within the package
```FMTOMO`` <http://iearth.edu.au/codes/FMTOMO/>`__ by Nick Rawlinson.


.. GENERATED FROM PYTHON SOURCE LINES 110-113

0. Import modules
-----------------


.. GENERATED FROM PYTHON SOURCE LINES 113-122

.. code-block:: default


    # -------------------------------------------------------- #
    #                                                          #
    #     Uncomment below to set up environment on "colab"     #
    #                                                          #
    # -------------------------------------------------------- #

    # !pip install -U cofi geo-espresso








.. GENERATED FROM PYTHON SOURCE LINES 124-132

.. code-block:: default


    import numpy as np
    import matplotlib.pyplot as plt
    import pprint

    import cofi
    import espresso








.. GENERATED FROM PYTHON SOURCE LINES 137-147

Problem setup
~~~~~~~~~~~~~

Before we starting working with ``cofi``, let’s get familiar with the
problem itself.

Below is a plot of the true model and the paths generated from this
model. As you can see, there are two anomalies, one with lower velocity
(red, top left) and the other with higher velocity (blue, bottom right).


.. GENERATED FROM PYTHON SOURCE LINES 147-152

.. code-block:: default


    fmm = espresso.FmmTomography()

    fmm.plot_model(fmm.good_model, with_paths=True);




.. image-sg:: /examples/generated/synth_data/images/sphx_glr_fmm_tomography_001.png
   :alt: fmm tomography
   :srcset: /examples/generated/synth_data/images/sphx_glr_fmm_tomography_001.png
   :class: sphx-glr-single-img


.. rst-class:: sphx-glr-script-out

 .. code-block:: none

     New data set has:
     10  receivers
     10  sources
     100  travel times
     Range of travel times:  0.008911182496368759 0.0153757024856463 
     Mean travel time: 0.01085811731230709
    Trying to fix now...
    Execute permission given to fm2dss.o.

    <Axes: >



.. GENERATED FROM PYTHON SOURCE LINES 154-157

.. code-block:: default


    pprint.pprint(fmm.metadata)





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    {'author_names': ['Nick Rawlinson', 'Malcolm Sambridge'],
     'citations': [('Rawlinson, N., de Kool, M. and Sambridge, M., 2006. Seismic '
                    'wavefront tracking in 3-D heterogeneous media: applications '
                    'with multiple data classes, Explor. Geophys., 37, 322-330.',
                    ''),
                   ('Rawlinson, N. and Urvoy, M., 2006. Simultaneous inversion of '
                    'active and passive source datasets for 3-D seismic structure '
                    'with application to Tasmania, Geophys. Res. Lett., 33 L24313',
                    '10.1029/2006GL028105'),
                   ('de Kool, M., Rawlinson, N. and Sambridge, M. 2006. A '
                    'practical grid based method for tracking multiple refraction '
                    'and reflection phases in 3D heterogeneous media, Geophys. J. '
                    'Int., 167, 253-270',
                    '')],
     'contact_email': 'Malcolm.Sambridge@anu.edu.au',
     'contact_name': 'Malcolm Sambridge',
     'linked_sites': [('Software published on iEarth',
                       'http://iearth.edu.au/codes/FMTOMO/')],
     'problem_short_description': 'The wave front tracker routines solves boundary '
                                  'value ray tracing problems into 2D '
                                  'heterogeneous wavespeed media, defined by '
                                  'continuously varying velocity model calculated '
                                  'by 2D cubic B-splines.',
     'problem_title': 'Fast Marching Wave Front Tracking'}




.. GENERATED FROM PYTHON SOURCE LINES 162-165

1. Define the problem
---------------------


.. GENERATED FROM PYTHON SOURCE LINES 165-172

.. code-block:: default


    # get problem information from  espresso FmmTomography
    model_size = fmm.model_size         # number of model parameters
    model_shape = fmm.model_shape       # 2D spatial grids
    data_size = fmm.data_size           # number of data points
    ref_start_slowness = fmm.starting_model








.. GENERATED FROM PYTHON SOURCE LINES 174-179

.. code-block:: default


    # define CoFI BaseProblem
    fmm_problem = cofi.BaseProblem()
    fmm_problem.set_initial_model(ref_start_slowness)








.. GENERATED FROM PYTHON SOURCE LINES 181-196

.. code-block:: default


    # add regularization: damping + smoothing
    damping_factor = 50
    smoothing_factor = 5e3
    reg_damping = damping_factor * cofi.utils.QuadraticReg(
        model_shape=model_shape, 
        weighting_matrix="damping", 
        reference_model=ref_start_slowness
    )
    reg_smoothing = smoothing_factor * cofi.utils.QuadraticReg(
        model_shape=model_shape,
        weighting_matrix="smoothing"
    )
    reg = reg_damping + reg_smoothing








.. GENERATED FROM PYTHON SOURCE LINES 198-224

.. code-block:: default


    def objective_func(slowness, reg, sigma, reduce_data=None):  # reduce_data=(idx_from, idx_to)
        if reduce_data is None: idx_from, idx_to = (0, fmm.data_size)
        else: idx_from, idx_to = reduce_data
        ttimes = fmm.forward(slowness)
        residual = fmm.data[idx_from:idx_to] - ttimes[idx_from:idx_to]
        data_misfit = residual.T @ residual / sigma**2
        model_reg = reg(slowness)
        return  data_misfit + model_reg
    def gradient(slowness, reg, sigma, reduce_data=None):       # reduce_data=(idx_from, idx_to)
        if reduce_data is None: idx_from, idx_to = (0, fmm.data_size)
        else: idx_from, idx_to = reduce_data
        ttimes, A = fmm.forward(slowness, with_jacobian=True)
        ttimes = ttimes[idx_from:idx_to]
        A = A[idx_from:idx_to]
        data_misfit_grad = -2 * A.T @ (fmm.data[idx_from:idx_to] - ttimes) / sigma**2
        model_reg_grad = reg.gradient(slowness)
        return  data_misfit_grad + model_reg_grad
    def hessian(slowness, reg, sigma, reduce_data=None):        # reduce_data=(idx_from, idx_to)
        if reduce_data is None: idx_from, idx_to = (0, fmm.data_size)
        else: idx_from, idx_to = reduce_data
        A = fmm.jacobian(slowness)[idx_from:idx_to]
        data_misfit_hess = 2 * A.T @ A / sigma**2 
        model_reg_hess = reg.hessian(slowness)
        return data_misfit_hess + model_reg_hess








.. GENERATED FROM PYTHON SOURCE LINES 226-233

.. code-block:: default


    sigma =  0.00001                   # Noise is 1.0E-4 is ~5% of standard deviation of initial travel time residuals

    fmm_problem.set_objective(objective_func, args=[reg, sigma, None])
    fmm_problem.set_gradient(gradient, args=[reg, sigma, None])
    fmm_problem.set_hessian(hessian, args=[reg, sigma, None])








.. GENERATED FROM PYTHON SOURCE LINES 238-240

Review what information is included in the ``BaseProblem`` object:


.. GENERATED FROM PYTHON SOURCE LINES 240-243

.. code-block:: default


    fmm_problem.summary()





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    =====================================================================
    Summary for inversion problem: BaseProblem
    =====================================================================
    Model shape: (1536,)
    ---------------------------------------------------------------------
    List of functions/properties set by you:
    ['objective', 'gradient', 'hessian', 'initial_model', 'model_shape']
    ---------------------------------------------------------------------
    List of functions/properties created based on what you have provided:
    ['hessian_times_vector']
    ---------------------------------------------------------------------
    List of functions/properties that can be further set for the problem:
    ( not all of these may be relevant to your inversion workflow )
    ['log_posterior', 'log_posterior_with_blobs', 'log_likelihood', 'log_prior', 'hessian_times_vector', 'residual', 'jacobian', 'jacobian_times_vector', 'data_misfit', 'regularization', 'regularization_matrix', 'forward', 'data', 'data_covariance', 'data_covariance_inv', 'blobs_dtype', 'bounds', 'constraints']




.. GENERATED FROM PYTHON SOURCE LINES 248-251

2. Define the inversion options
-------------------------------


.. GENERATED FROM PYTHON SOURCE LINES 251-258

.. code-block:: default


    my_options = cofi.InversionOptions()

    # cofi's own simple newton's matrix-based optimization solver
    my_options.set_tool("cofi.simple_newton")
    my_options.set_params(num_iterations=6, step_length=1, verbose=True)








.. GENERATED FROM PYTHON SOURCE LINES 263-265

Review what’s been defined for the inversion we are about to run:


.. GENERATED FROM PYTHON SOURCE LINES 265-268

.. code-block:: default


    my_options.summary()





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    =============================
    Summary for inversion options
    =============================
    Solving method: None set
    Use `suggest_solving_methods()` to check available solving methods.
    -----------------------------
    Backend tool: `<class 'cofi.tools._cofi_simple_newton.CoFISimpleNewton'>` - CoFI's own solver - simple Newton's approach (for testing mainly)
    References: ['https://en.wikipedia.org/wiki/Newton%27s_method_in_optimization']
    Use `suggest_tools()` to check available backend tools.
    -----------------------------
    Solver-specific parameters: 
    num_iterations = 6
    step_length = 1
    verbose = True
    Use `suggest_solver_params()` to check required/optional solver-specific parameters.




.. GENERATED FROM PYTHON SOURCE LINES 273-276

3. Start an inversion
---------------------


.. GENERATED FROM PYTHON SOURCE LINES 276-281

.. code-block:: default


    inv = cofi.Inversion(fmm_problem, my_options)
    inv_result = inv.run()
    inv_result.summary()





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    Iteration #0, objective function value: 110298.7001724638
    Iteration #1, objective function value: 1787.0459655957825
    Iteration #2, objective function value: 121.09918298452581
    Iteration #3, objective function value: 5.805217146094518
    Iteration #4, objective function value: 3.853291569236922
    Iteration #5, objective function value: 1.6509714163979023
    ============================
    Summary for inversion result
    ============================
    SUCCESS
    ----------------------------
    model: [0.00048363 0.0004817  0.00048005 ... 0.00050727 0.00050677 0.00050617]
    num_iterations: 5
    objective_val: 2.717895837439228
    n_obj_evaluations: 6
    n_grad_evaluations: 6
    n_hess_evaluations: 6




.. GENERATED FROM PYTHON SOURCE LINES 286-289

4. Plotting
-----------


.. GENERATED FROM PYTHON SOURCE LINES 289-293

.. code-block:: default


    fmm.plot_model(inv_result.model);            # inverted model
    fmm.plot_model(fmm.good_model);       # true model




.. rst-class:: sphx-glr-horizontal


    *

      .. image-sg:: /examples/generated/synth_data/images/sphx_glr_fmm_tomography_002.png
         :alt: fmm tomography
         :srcset: /examples/generated/synth_data/images/sphx_glr_fmm_tomography_002.png
         :class: sphx-glr-multi-img

    *

      .. image-sg:: /examples/generated/synth_data/images/sphx_glr_fmm_tomography_003.png
         :alt: fmm tomography
         :srcset: /examples/generated/synth_data/images/sphx_glr_fmm_tomography_003.png
         :class: sphx-glr-multi-img


.. rst-class:: sphx-glr-script-out

 .. code-block:: none


    <Axes: >



.. GENERATED FROM PYTHON SOURCE LINES 298-311

--------------

Watermark
---------

.. raw:: html

   <!-- Feel free to add more modules in the watermark_list below, if more packages are used -->

.. raw:: html

   <!-- Otherwise please leave the below code cell unchanged -->


.. GENERATED FROM PYTHON SOURCE LINES 311-317

.. code-block:: default


    watermark_list = ["cofi", "espresso", "numpy", "matplotlib"]
    for pkg in watermark_list:
        pkg_var = __import__(pkg)
        print(pkg, getattr(pkg_var, "__version__"))





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    cofi 0.2.0
    espresso 0.3.7
    numpy 1.24.3
    matplotlib 3.7.1




.. GENERATED FROM PYTHON SOURCE LINES 318-318

sphinx_gallery_thumbnail_number = -1


.. rst-class:: sphx-glr-timing

   **Total running time of the script:** ( 0 minutes  8.938 seconds)


.. _sphx_glr_download_examples_generated_synth_data_fmm_tomography.py:

.. only:: html

  .. container:: sphx-glr-footer sphx-glr-footer-example




    .. container:: sphx-glr-download sphx-glr-download-python

      :download:`Download Python source code: fmm_tomography.py <fmm_tomography.py>`

    .. container:: sphx-glr-download sphx-glr-download-jupyter

      :download:`Download Jupyter notebook: fmm_tomography.ipynb <fmm_tomography.ipynb>`


.. only:: html

 .. rst-class:: sphx-glr-signature

    `Gallery generated by Sphinx-Gallery <https://sphinx-gallery.github.io>`_
