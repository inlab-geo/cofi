
.. DO NOT EDIT.
.. THIS FILE WAS AUTOMATICALLY GENERATED BY SPHINX-GALLERY.
.. TO MAKE CHANGES, EDIT THE SOURCE PYTHON FILE:
.. "examples/generated/synth_data/fmm_tomography_regularization_discussion.py"
.. LINE NUMBERS ARE GIVEN BELOW.

.. only:: html

    .. note::
        :class: sphx-glr-download-link-note

        :ref:`Go to the end <sphx_glr_download_examples_generated_synth_data_fmm_tomography_regularization_discussion.py>`
        to download the full example code

.. rst-class:: sphx-glr-example-title

.. _sphx_glr_examples_generated_synth_data_fmm_tomography_regularization_discussion.py:


Seismic Wave Tomography via Fast Marching - Demo on switching regularization and L-curve
========================================================================================

.. GENERATED FROM PYTHON SOURCE LINES 9-14

|Open In Colab|

.. |Open In Colab| image:: https://img.shields.io/badge/open%20in-Colab-b5e2fa?logo=googlecolab&style=flat-square&color=ffd670
   :target: https://colab.research.google.com/github/inlab-geo/cofi-examples/blob/main/examples/fmm_tomography/fmm_tomography.ipynb


.. GENERATED FROM PYTHON SOURCE LINES 17-36

.. raw:: html

   <!-- Again, please don't touch the markdown cell above. We'll generate badge 
        automatically from the above cell. -->

.. raw:: html

   <!-- This cell describes things related to environment setup, so please add more text 
        if something special (not listed below) is needed to run this notebook -->

..

   If you are running this notebook locally, make sure you’ve followed
   `steps
   here <https://github.com/inlab-geo/cofi-examples#run-the-examples-with-cofi-locally>`__
   to set up the environment. (This
   `environment.yml <https://github.com/inlab-geo/cofi-examples/blob/main/envs/environment.yml>`__
   file specifies a list of packages required to run the notebooks)


.. GENERATED FROM PYTHON SOURCE LINES 39-54

.. raw:: html

   <!-- TODO - background introduction for this problem. -->

In this notebook, we would like to demonstrate the capability of CoFI to
easily switch between different types of regularizations.

We will use ``cofi`` to run a seismic wave tomography example, in which
the forward calculation is based on the Fast Marching Fortran code by
Nick Rawlinson. The Fast Marching code is wrapped in package
``espresso``.

We refer you to `fmm_tomography.ipynb <./fmm_tomography.ipynb>`__ for
further theretical details.


.. GENERATED FROM PYTHON SOURCE LINES 57-60

0. Import modules
-----------------


.. GENERATED FROM PYTHON SOURCE LINES 60-69

.. code-block:: default


    # -------------------------------------------------------- #
    #                                                          #
    #     Uncomment below to set up environment on "colab"     #
    #                                                          #
    # -------------------------------------------------------- #

    # !pip install -U cofi geo-espresso








.. GENERATED FROM PYTHON SOURCE LINES 71-79

.. code-block:: default


    import numpy as np
    import matplotlib.pyplot as plt
    import pprint

    import cofi
    import espresso








.. GENERATED FROM PYTHON SOURCE LINES 84-94

Understanding the inference problem
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Before we starting working with ``cofi``, let’s get familiar with the
problem itself.

Below is a plot of the true model and the paths generated from this
model. As you can see, there are two anomalies, one with lower velocity
(red, top left) and the other with higher velocity (blue, bottom right).


.. GENERATED FROM PYTHON SOURCE LINES 94-99

.. code-block:: default


    fmm = espresso.FmmTomography()

    fmm.plot_model(fmm.good_model, with_paths=True);




.. image-sg:: /examples/generated/synth_data/images/sphx_glr_fmm_tomography_regularization_discussion_001.png
   :alt: fmm tomography regularization discussion
   :srcset: /examples/generated/synth_data/images/sphx_glr_fmm_tomography_regularization_discussion_001.png
   :class: sphx-glr-single-img


.. rst-class:: sphx-glr-script-out

 .. code-block:: none

     New data set has:
     10  receivers
     10  sources
     100  travel times
     Range of travel times:  0.008911182496368759 0.0153757024856463 
     Mean travel time: 0.01085811731230709

    <Axes: xlabel='x (km)', ylabel='y (km)'>



.. GENERATED FROM PYTHON SOURCE LINES 101-104

.. code-block:: default


    pprint.pprint(fmm.metadata)





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    {'author_names': ['Nick Rawlinson', 'Malcolm Sambridge'],
     'citations': [('Rawlinson, N., de Kool, M. and Sambridge, M., 2006. Seismic '
                    'wavefront tracking in 3-D heterogeneous media: applications '
                    'with multiple data classes, Explor. Geophys., 37, 322-330.',
                    ''),
                   ('Rawlinson, N. and Urvoy, M., 2006. Simultaneous inversion of '
                    'active and passive source datasets for 3-D seismic structure '
                    'with application to Tasmania, Geophys. Res. Lett., 33 L24313',
                    '10.1029/2006GL028105'),
                   ('de Kool, M., Rawlinson, N. and Sambridge, M. 2006. A '
                    'practical grid based method for tracking multiple refraction '
                    'and reflection phases in 3D heterogeneous media, Geophys. J. '
                    'Int., 167, 253-270',
                    ''),
                   ('Saygin, E. 2007. Seismic receiver and noise correlation based '
                    'studies in Australia, PhD thesis, Australian National '
                    'University.',
                    '10.25911/5d7a2d1296f96')],
     'contact_email': 'Malcolm.Sambridge@anu.edu.au',
     'contact_name': 'Malcolm Sambridge',
     'linked_sites': [('Software published on iEarth',
                       'http://iearth.edu.au/codes/FMTOMO/')],
     'problem_short_description': 'The wave front tracker routines solves boundary '
                                  'value ray tracing problems into 2D '
                                  'heterogeneous wavespeed media, defined by '
                                  'continuously varying velocity model calculated '
                                  'by 2D cubic B-splines.',
     'problem_title': 'Fast Marching Wave Front Tracking'}




.. GENERATED FROM PYTHON SOURCE LINES 109-112

1. Problem setup and utilities
------------------------------


.. GENERATED FROM PYTHON SOURCE LINES 112-119

.. code-block:: default


    # get problem information from  espresso FmmTomography
    model_size = fmm.model_size         # number of model parameters
    model_shape = fmm.model_shape       # 2D spatial grids
    data_size = fmm.data_size           # number of data points
    ref_start_slowness = fmm.starting_model








.. GENERATED FROM PYTHON SOURCE LINES 121-141

.. code-block:: default


    def objective_func(slowness, reg):
        ttimes = fmm.forward(slowness)
        residual = fmm.data - ttimes
        data_misfit = residual.T @ residual
        model_reg = reg(slowness)
        return data_misfit + model_reg

    def gradient(slowness, reg):
        ttimes, A = fmm.forward(slowness, return_jacobian=True)
        data_misfit_grad = -2 * A.T @ (fmm.data - ttimes)
        model_reg_grad = reg.gradient(slowness)
        return data_misfit_grad + model_reg_grad

    def hessian(slowness, reg):
        A = fmm.jacobian(slowness)
        data_misfit_hess = 2 * A.T @ A
        model_reg_hess = reg.hessian(slowness)
        return data_misfit_hess + model_reg_hess








.. GENERATED FROM PYTHON SOURCE LINES 146-152

2. Invert with quadratic smoothing and damping regularization terms
-------------------------------------------------------------------

2.1 Define BaseProblem
~~~~~~~~~~~~~~~~~~~~~~


.. GENERATED FROM PYTHON SOURCE LINES 152-157

.. code-block:: default


    # define CoFI BaseProblem
    fmm_problem_quadratic_reg = cofi.BaseProblem()
    fmm_problem_quadratic_reg.set_initial_model(ref_start_slowness)








.. GENERATED FROM PYTHON SOURCE LINES 159-167

.. code-block:: default


    # add regularization: flattening + smoothing
    smoothing_factor = 0.001
    reg_smoothing = smoothing_factor * cofi.utils.QuadraticReg(
        model_shape=model_shape,
        weighting_matrix="smoothing"
    )








.. GENERATED FROM PYTHON SOURCE LINES 169-174

.. code-block:: default


    fmm_problem_quadratic_reg.set_objective(objective_func, args=[reg_smoothing])
    fmm_problem_quadratic_reg.set_gradient(gradient, args=[reg_smoothing])
    fmm_problem_quadratic_reg.set_hessian(hessian, args=[reg_smoothing])








.. GENERATED FROM PYTHON SOURCE LINES 179-182

2.2 Define InversionOptions
~~~~~~~~~~~~~~~~~~~~~~~~~~~


.. GENERATED FROM PYTHON SOURCE LINES 182-194

.. code-block:: default


    my_options = cofi.InversionOptions()

    my_options.set_tool("cofi.simple_newton")
    my_options.set_params(
        num_iterations=15, 
        step_length=1, 
        obj_tol=1e-16,
        verbose=True, 
        hessian_is_symmetric=True
    )








.. GENERATED FROM PYTHON SOURCE LINES 199-202

2.3 Start an inversion
~~~~~~~~~~~~~~~~~~~~~~


.. GENERATED FROM PYTHON SOURCE LINES 202-207

.. code-block:: default


    inv = cofi.Inversion(fmm_problem_quadratic_reg, my_options)
    inv_result_quadratic_reg = inv.run()
    inv_result_quadratic_reg.summary()





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    Iteration #0, updated objective function value: 1.733350359903498e-07
    Iteration #1, updated objective function value: 2.4528941433689466e-09
    Iteration #2, updated objective function value: 1.6667499773269517e-10
    Iteration #3, updated objective function value: 3.3183038228463554e-11
    Iteration #4, updated objective function value: 3.8531578708747634e-11
    Iteration #5, updated objective function value: 1.9386143575359088e-11
    Iteration #6, updated objective function value: 3.2610301145716735e-11
    Iteration #7, updated objective function value: 1.6209545072977018e-11
    Iteration #8, updated objective function value: 2.8940439339590962e-11
    Iteration #9, updated objective function value: 1.504739631713362e-11
    Iteration #10, updated objective function value: 2.703178700016917e-11
    Iteration #11, updated objective function value: 1.4195102480742004e-11
    Iteration #12, updated objective function value: 2.5989058410062935e-11
    Iteration #13, updated objective function value: 1.3980620229249818e-11
    Iteration #14, updated objective function value: 2.5341981735230692e-11
    ============================
    Summary for inversion result
    ============================
    SUCCESS
    ----------------------------
    model: [0.00050485 0.00049715 0.00048991 ... 0.00050558 0.00050199 0.00049801]
    num_iterations: 14
    objective_val: 2.5341981735230692e-11
    n_obj_evaluations: 16
    n_grad_evaluations: 15
    n_hess_evaluations: 15




.. GENERATED FROM PYTHON SOURCE LINES 212-215

2.4 Plotting
~~~~~~~~~~~~


.. GENERATED FROM PYTHON SOURCE LINES 215-221

.. code-block:: default


    clim = (1/np.max(fmm.good_model)-1, 1/np.min(fmm.good_model)+1)

    fmm.plot_model(inv_result_quadratic_reg.model, clim=clim);            # inverted model
    fmm.plot_model(fmm.good_model);       # true model




.. rst-class:: sphx-glr-horizontal


    *

      .. image-sg:: /examples/generated/synth_data/images/sphx_glr_fmm_tomography_regularization_discussion_002.png
         :alt: fmm tomography regularization discussion
         :srcset: /examples/generated/synth_data/images/sphx_glr_fmm_tomography_regularization_discussion_002.png
         :class: sphx-glr-multi-img

    *

      .. image-sg:: /examples/generated/synth_data/images/sphx_glr_fmm_tomography_regularization_discussion_003.png
         :alt: fmm tomography regularization discussion
         :srcset: /examples/generated/synth_data/images/sphx_glr_fmm_tomography_regularization_discussion_003.png
         :class: sphx-glr-multi-img


.. rst-class:: sphx-glr-script-out

 .. code-block:: none


    <Axes: xlabel='x (km)', ylabel='y (km)'>



.. GENERATED FROM PYTHON SOURCE LINES 226-244

--------------

3. Invert with Gaussian prior as regularization term
----------------------------------------------------

Instead of using a smoothing and damping regularization, in this
section, we use a model covariance matrix and prior model.

:math:`\chi_{P}^{2}=\left(\mathbf{y} -\mathbf{f}(\mathbf{m})\right)^T C_d^{-1} \left(\mathbf{y} -\mathbf{f}(\mathbf{m})\right) + \left( \mathbf{m} - \mathbf{m}_p \right)^T C_p^{-1} \left( \mathbf{m} - \mathbf{m}_p \right)`

:math:`\Delta \mathbf{m}= ({J}^T {C}_d^{-1} {J}+{C}_p^{-1})^{-1} ({J}^T{C}_d^{-1} (\mathbf{y}-\mathbf{f}(\mathbf{m}))+{C}_p^{-1}(\mathbf{m}_p-\mathbf{m}))`

We can use CoFI’s utility module to help us generate a the Gaussian
prior term.

3.1 Define BaseProblem
~~~~~~~~~~~~~~~~~~~~~~


.. GENERATED FROM PYTHON SOURCE LINES 244-249

.. code-block:: default


    # define CoFI BaseProblem
    fmm_problem_gaussian_prior = cofi.BaseProblem()
    fmm_problem_gaussian_prior.set_initial_model(ref_start_slowness)








.. GENERATED FROM PYTHON SOURCE LINES 251-261

.. code-block:: default


    # add regularization: Gaussian prior
    corrx = 3.0
    corry = 3.0
    sigma_slowness = 0.5
    gaussian_prior = cofi.utils.GaussianPrior(
        model_covariance_inv=((corrx, corry), sigma_slowness),
        mean_model=ref_start_slowness.reshape(model_shape)
    )








.. GENERATED FROM PYTHON SOURCE LINES 263-268

.. code-block:: default


    fmm_problem_gaussian_prior.set_objective(objective_func, args=[gaussian_prior])
    fmm_problem_gaussian_prior.set_gradient(gradient, args=[gaussian_prior])
    fmm_problem_gaussian_prior.set_hessian(hessian, args=[gaussian_prior])








.. GENERATED FROM PYTHON SOURCE LINES 273-276

3.2 Start an inversion
~~~~~~~~~~~~~~~~~~~~~~


.. GENERATED FROM PYTHON SOURCE LINES 276-282

.. code-block:: default


    # reuse the previously defined InversionOptions object
    inv = cofi.Inversion(fmm_problem_gaussian_prior, my_options)
    inv_result_gaussian_prior = inv.run()
    inv_result_gaussian_prior.summary()





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    Iteration #0, updated objective function value: 3.633219726912791e-07
    Iteration #1, updated objective function value: 2.350718903302728e-07
    Iteration #2, updated objective function value: 2.3157837862854732e-07
    Iteration #3, updated objective function value: 2.3147517909945304e-07
    Iteration #4, updated objective function value: 2.3140410377488268e-07
    Change in model parameters below tolerance, stopping.
    ============================
    Summary for inversion result
    ============================
    SUCCESS
    ----------------------------
    model: [0.00049703 0.00049595 0.00049451 ... 0.000503   0.00050221 0.00050161]
    num_iterations: 4
    objective_val: 2.3140410377488268e-07
    n_obj_evaluations: 6
    n_grad_evaluations: 5
    n_hess_evaluations: 5




.. GENERATED FROM PYTHON SOURCE LINES 287-290

3.3 Plotting
~~~~~~~~~~~~


.. GENERATED FROM PYTHON SOURCE LINES 290-294

.. code-block:: default


    fmm.plot_model(inv_result_gaussian_prior.model, clim=clim);            # gaussian prior
    fmm.plot_model(fmm.good_model);       # true model




.. rst-class:: sphx-glr-horizontal


    *

      .. image-sg:: /examples/generated/synth_data/images/sphx_glr_fmm_tomography_regularization_discussion_004.png
         :alt: fmm tomography regularization discussion
         :srcset: /examples/generated/synth_data/images/sphx_glr_fmm_tomography_regularization_discussion_004.png
         :class: sphx-glr-multi-img

    *

      .. image-sg:: /examples/generated/synth_data/images/sphx_glr_fmm_tomography_regularization_discussion_005.png
         :alt: fmm tomography regularization discussion
         :srcset: /examples/generated/synth_data/images/sphx_glr_fmm_tomography_regularization_discussion_005.png
         :class: sphx-glr-multi-img


.. rst-class:: sphx-glr-script-out

 .. code-block:: none


    <Axes: xlabel='x (km)', ylabel='y (km)'>



.. GENERATED FROM PYTHON SOURCE LINES 299-304

4. L-curve
----------

Now we plot an L-curve for the smoothing regularization case.


.. GENERATED FROM PYTHON SOURCE LINES 304-336

.. code-block:: default


    lambdas = np.logspace(-4, 4, 15)

    my_lcurve_problems = []
    for lamb in lambdas:
        my_reg = lamb * reg_smoothing
        my_problem = cofi.BaseProblem()
        my_problem.set_objective(objective_func, args=[my_reg])
        my_problem.set_gradient(gradient, args=[my_reg])
        my_problem.set_hessian(hessian, args=[my_reg])
        my_problem.set_initial_model(ref_start_slowness)
        my_lcurve_problems.append(my_problem)

    my_options.set_params(verbose=False)

    def my_callback(inv_result, i):
        m = inv_result.model
        res_norm = np.linalg.norm(fmm.forward(m) - fmm.data)
        reg_norm = np.sqrt(reg_smoothing(m))
        print(f"Finished inversion with lambda={lambdas[i]}: {res_norm}, {reg_norm}")
        return res_norm, reg_norm

    my_inversion_pool = cofi.utils.InversionPool(
        my_lcurve_problems, 
        my_options, 
        my_callback, 
        True
    )
    all_res, all_cb_returns = my_inversion_pool.run()

    l_curve_points = list(zip(*all_cb_returns))








.. GENERATED FROM PYTHON SOURCE LINES 338-354

.. code-block:: default


    # plot the L-curve
    res_norm, reg_norm = l_curve_points
    plt.plot(reg_norm, res_norm, '.-')
    plt.xlabel(r'Norm of regularization term $||Wm||_2$')
    plt.ylabel(r'Norm of residual $||g(m)-d||_2$')
    for i in range(len(lambdas)):
        plt.annotate(f'{lambdas[i]:.1e}', (reg_norm[i], res_norm[i]), fontsize=8)

    # plot the previously solved model
    my_inverted_model = inv_result_quadratic_reg.model
    my_reg_norm = np.sqrt(reg_smoothing(my_inverted_model))
    my_residual_norm = np.linalg.norm(fmm.forward(my_inverted_model) - fmm.data)
    plt.plot(my_reg_norm, my_residual_norm, "x")
    plt.annotate(f"{smoothing_factor:.1e}", (my_reg_norm, my_residual_norm), fontsize=8);




.. image-sg:: /examples/generated/synth_data/images/sphx_glr_fmm_tomography_regularization_discussion_006.png
   :alt: fmm tomography regularization discussion
   :srcset: /examples/generated/synth_data/images/sphx_glr_fmm_tomography_regularization_discussion_006.png
   :class: sphx-glr-single-img


.. rst-class:: sphx-glr-script-out

 .. code-block:: none


    Text(2.7724031859576007e-06, 4.201876046449114e-06, '1.0e-03')



.. GENERATED FROM PYTHON SOURCE LINES 359-372

--------------

Watermark
---------

.. raw:: html

   <!-- Feel free to add more modules in the watermark_list below, if more packages are used -->

.. raw:: html

   <!-- Otherwise please leave the below code cell unchanged -->


.. GENERATED FROM PYTHON SOURCE LINES 372-378

.. code-block:: default


    watermark_list = ["cofi", "espresso", "numpy", "matplotlib"]
    for pkg in watermark_list:
        pkg_var = __import__(pkg)
        print(pkg, getattr(pkg_var, "__version__"))





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    cofi 0.2.3
    espresso 0.3.11
    numpy 1.24.3
    matplotlib 3.7.1




.. GENERATED FROM PYTHON SOURCE LINES 379-379

sphinx_gallery_thumbnail_number = -1


.. rst-class:: sphx-glr-timing

   **Total running time of the script:** ( 1 minutes  10.353 seconds)


.. _sphx_glr_download_examples_generated_synth_data_fmm_tomography_regularization_discussion.py:

.. only:: html

  .. container:: sphx-glr-footer sphx-glr-footer-example




    .. container:: sphx-glr-download sphx-glr-download-python

      :download:`Download Python source code: fmm_tomography_regularization_discussion.py <fmm_tomography_regularization_discussion.py>`

    .. container:: sphx-glr-download sphx-glr-download-jupyter

      :download:`Download Jupyter notebook: fmm_tomography_regularization_discussion.ipynb <fmm_tomography_regularization_discussion.ipynb>`


.. only:: html

 .. rst-class:: sphx-glr-signature

    `Gallery generated by Sphinx-Gallery <https://sphinx-gallery.github.io>`_
